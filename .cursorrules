<cursor_rule>
  <project_context>
    <name>Cattle Tracking SaaS Application</name>
    <description>
      Multi-tenant SaaS application for tracking cattle in feedlots. The system consists of a top-level website that serves as a hub to navigate between individual feedlot instances (SaaS tenants). Each feedlot manages pens, batches of inducted cattle, and individual cattle details.
    </description>
  </project_context>

  <tech_stack>
    <backend>Python with Flask</backend>
    <frontend>Tailwind CSS</frontend>
    <database>MongoDB</database>
    <authentication>User login system for both top-level and SaaS-level users</authentication>
  </tech_stack>

  <architecture>
    <multi_tenant_structure>
      <level name="top_level">
        Main hub for navigation, access to all feedlot instances, top-level user authentication and management
      </level>
      <level name="feedlot_instances">
        Individual feedlot dashboards, feedlot-specific user authentication, manages pens, batches, and cattle
      </level>
      <hierarchy>
        Top-Level Hub → Feedlot Instance → (Pens | Batches | Individual Cattle Details)
      </hierarchy>
    </multi_tenant_structure>
  </architecture>

  <user_management>
    <user_types>
      <type name="top_level_users">
        Can access the main hub, navigate between different feedlot instances, manage feedlot accounts
      </type>
      <type name="saas_level_users">
        Access specific to their feedlot instance, manage pens/batches/cattle within their feedlot, cannot access other feedlot instances
      </type>
    </user_types>
    <terminology_clarifications>
      <term name="top_level">
        Refers to Super Owner and Super Admin user types. These are the highest-level users with system-wide access.
      </term>
      <term name="business_level">
        Refers to all user types that are not top level (i.e., all user types except Super Owner and Super Admin). These users operate within specific feedlot instances.
      </term>
    </terminology_clarifications>
    <authentication_requirements>
      - Separate authentication contexts for top-level vs feedlot-level
      - Role-based access control (RBAC)
      - Secure session management
      - Password encryption and security best practices
    </authentication_requirements>
  </user_management>

  <database_schema>
    <collections>
      <collection name="users">Top-level and feedlot users</collection>
      <collection name="feedlots">Feedlot instances/tenants</collection>
      <collection name="pens">Physical pen locations within feedlots</collection>
      <collection name="batches">Groups of cattle inducted together</collection>
      <collection name="cattle">Individual cattle records</collection>
    </collections>
    <relationships>
      - Feedlots contain multiple pens and batches
      - Batches contain multiple cattle
      - Cattle are assigned to pens
      - Users are associated with feedlots (for SaaS-level users)
    </relationships>
  </database_schema>

  <ui_ux_requirements>
    <responsive_design>
      - Follow best practices for multiple screen sizes
      - Mobile-first approach using Tailwind CSS
      - Breakpoints: mobile (&lt; 640px), tablet (640px - 1024px), desktop (&gt; 1024px)
      - Ensure all features are accessible across devices
      - Touch-friendly interfaces for mobile/tablet
      - Optimized navigation for smaller screens
    </responsive_design>
    <design_principles>
      - Clean, modern interface using Tailwind CSS utilities
      - Intuitive navigation between hierarchy levels
      - Clear visual distinction between top-level and feedlot contexts
      - Consistent component design across the application
      - Accessible forms and data tables
    </design_principles>
  </ui_ux_requirements>

  <core_features>
    <top_level_website>
      - Dashboard showing all feedlot instances
      - Feedlot management (create, edit, view)
      - User management for top-level access
      - Navigation to individual feedlot instances
    </top_level_website>
    <feedlot_instance>
      <pen_management>
        Create, view, edit, delete pens | View cattle currently in each pen | Pen capacity tracking
      </pen_management>
      <batch_management>
        Record cattle induction in batches | Track batch details (induction date, source, etc.) | View all cattle in a batch
      </batch_management>
      <cattle_details>
        Individual cattle records | Track cattle information (ID, breed, weight, health status, etc.) | Movement history between pens | Batch association
      </cattle_details>
    </feedlot_instance>
    <authentication_flow>
      Login pages for both top-level and feedlot users | Session management | Logout functionality | Password reset capability
    </authentication_flow>
  </core_features>

  <technical_guidelines>
    <flask_structure>
      /app
        /routes (top_level_routes.py, feedlot_routes.py, auth_routes.py)
        /models (user.py, feedlot.py, pen.py, batch.py, cattle.py)
        /templates (Base templates with Tailwind CSS)
        /static (CSS, JS, images)
        config.py
        __init__.py
    </flask_structure>
    <mongodb_best_practices>
      - Use proper indexing for performance
      - Implement data validation
      - Handle multi-tenant data isolation
      - Efficient querying with aggregation pipelines where needed
    </mongodb_best_practices>
    <security>
      - Input validation and sanitization
      - CSRF protection
      - NoSQL injection prevention for MongoDB
      - Secure password hashing (bcrypt)
      - Environment variables for sensitive data
      - JWT or session-based authentication
    </security>
    <code_quality>
      - Follow PEP 8 style guidelines for Python
      - Write clean, maintainable code
      - Include error handling and logging
      - Add comments for complex logic
      - Modular and reusable components
    </code_quality>
    <testing_attributes>
      All HTML templates must include data-testid attributes on interactive elements for automated testing:
      - Use kebab-case naming convention (e.g., "create-pen-button", "feedlot-name-input")
      - Include context in names to make them unique and descriptive (e.g., "api-key-generate-button" not just "generate-button")
      - Add data-testid to all buttons, forms, input fields, select dropdowns, links, modals, table rows, and dropdown menus
      - Use descriptive names that indicate the element's purpose and context (e.g., "edit-feedlot-form", "cancel-create-pen-button")
      - For dynamic content (like table rows), include identifiers in the testid (e.g., "feedlot-user-row-{{ user._id }}")
      - Modal elements should have testids for the modal container, close buttons, form inputs, and action buttons
      - Dropdown menus should have testids for the dropdown button, menu container, and individual menu items
      - Forms should have a testid on the form element itself, plus all inputs, selects, textareas, and submit/cancel buttons
      - Search inputs should use testids like "search-{entity}-input" (e.g., "search-feedlots-input", "search-cattle-input")
      - Action items in sidebars should use testids like "{action}-{entity}-action" (e.g., "create-pen-action", "edit-feedlot-action")
      - Widgets and sections should have testids for easy identification (e.g., "widget-feedlots", "widget-pens")
    </testing_attributes>
  </technical_guidelines>

  <development_priorities>
    1. Set up Flask application structure and MongoDB connection
    2. Implement authentication system (top-level and feedlot)
    3. Build top-level hub with feedlot navigation
    4. Create feedlot instance views
    5. Implement pen management
    6. Implement batch management
    7. Implement cattle details and tracking
    8. Ensure responsive design across all views
    9. Add data validation and security measures
    10. Testing and refinement
  </development_priorities>

  <coding_instructions>
    When generating code for this project:
    - Always consider the multi-tenant context and data isolation
    - Ensure clear separation between top-level and feedlot contexts
    - Maintain consistent naming conventions
    - Plan for scalability as feedlots and cattle data grow
    - Consider pagination for large datasets
    - Implement search and filter functionality where appropriate
    - Use Tailwind CSS utility classes for all styling
    - Ensure responsive design patterns are applied
    - Include proper error handling and user feedback
    - Write self-documenting code with clear variable and function names
    - ALWAYS add data-testid attributes to all interactive HTML elements (buttons, forms, inputs, links, modals, dropdowns, tables) following the testing_attributes guidelines
  </coding_instructions>

  <ui_components>
    <actions_sidebar>
      The "Management" sidebar must always follow this exact pattern:
      - Layout: Use a flex container with "flex flex-col md:flex-row gap-6" wrapping both main content and sidebar
      - Main content: Place in a div with class "flex-1" (comes first in the flex container)
      - Sidebar container: Use block "actions_sidebar" with ID "actions-sidebar" and data-testid="{page}-actions-sidebar"
      - Sidebar styling: "bg-white rounded-lg shadow-md p-4 md:min-w-[200px] md:max-w-[200px] flex-shrink-0"
      - Sidebar CSS: Includes "align-self: flex-start" to prevent stretching to match content height (defined in base.html)
      - Sidebar header: "Management" heading with class "text-sm font-semibold text-gray-700 mb-3 uppercase tracking-wider"
      - Action items container: div with class "space-y-1" containing all action items
      - Action items: Each link/button should have classes "block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900 transition-colors rounded"
      - Action items for buttons: Add "w-full text-left cursor-pointer" classes
      - Action items for links: Standard anchor tags with the same styling classes
      - Responsive: On mobile (max-width: 768px), sidebar stacks above content and uses full width
      - Position: Sidebar appears on the RIGHT side of the page (after main content in flex order)
      - Height: Sidebar only takes up height needed for its content (does not stretch to match main content)
      - No JavaScript required: Sidebar is always visible, no dropdown functionality needed
      - Test IDs: Use pattern "{action}-{entity}-action" for action items (e.g., "create-pen-action", "edit-feedlot-action")
    </actions_sidebar>
    <confirmation_dialogs>
      ALL confirmation dialogs MUST use modal dialogs, NEVER use JavaScript confirm() or alert():
      - Modal structure: Use a div with classes "hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4"
      - Modal container: Inner div with classes "bg-white rounded-lg shadow-xl max-w-md w-full" (or max-w-lg for larger modals)
      - Modal header: Include a title and close button (X icon) in a border-b section
      - Modal content: Clear message explaining the action and its consequences
      - Modal actions: Two buttons - one for confirmation (destructive actions use red bg-red-600), one for cancel (gray bg-gray-600)
      - JavaScript functions: open{ModalName}Modal() and close{ModalName}Modal() functions to toggle the "hidden" class
      - Body scroll lock: Set document.body.style.overflow = 'hidden' when opening, 'auto' when closing
      - Escape key: Add event listener to close modal on Escape key press
      - Click outside: Close modal when clicking on the backdrop (the outer modal div)
      - Form submission: The confirmation button should submit a form, not use onclick with confirm()
      - Test IDs: Modal container, close button, form, confirm button, and cancel button all need data-testid attributes
      - Pattern: "{action}-{entity}-modal", "{action}-{entity}-form", "confirm-{action}-{entity}-button", "cancel-{action}-{entity}-button"
    </confirmation_dialogs>
  </ui_components>
</cursor_rule>

